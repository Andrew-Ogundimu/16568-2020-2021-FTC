package teamcode;

import android.os.Environment;

import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.ReadWriteFile;

import org.firstinspires.ftc.robotcore.external.ClassFactory;
import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static java.lang.Boolean.parseBoolean;
import static java.lang.Integer.parseInt;
import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;
import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;
import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.FRONT;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;

@Autonomous(name = "Auton_SkystoneReadFileLeft") //we turn left after skystones
@Disabled

public class Read_File extends OpMode{
    //Declare the DcMotors

    DcMotor fl; //front left motor
    DcMotor fr; //front right motor
    DcMotor bl; //back left motor
    DcMotor br; //back right motor
    private int step = 1;
    private double wheelCircum = (1.97 * 2) * Math.PI;
    private int ticksPerTurn = 1120; //our gear ratio is 1:1
    private int targetPosition = 0;
    private int iter = 0;
    private boolean oneIsNull = false;
    private boolean flReached = false;
    private boolean frReached = false;
    private boolean blReached = false;
    private boolean brReached = false;
    private int nextStep = 0;
    private BNO055IMU imu;
    private AngleUnit unit = AngleUnit.DEGREES; //for the gyro
    private double gyroTarget;
    private double gyroRange;
    private double gyroActual;
    private double minSpeed;
    private double addSpeed;
    private ColorSensor colorSensor;
    private BNO055IMU.Parameters parameters;
    private float lastAngle = 0;
    private static final double kp = 1.5; //increased a lot
    private static final double kd = 0.6; //reduced to minimize slowed speed
    private static final double ki = 0.01; //small
    private double error = 0;
    private double prev_error;
    private double diff_error;
    private double sum_error;
    private double toBridgeDist;
    private double encoderStartingPosition = 0;
    private double encoderEndingPosition = 0;
    private double encoderMovedPosition = 0;
    double distanceToDrive = 0;
    private boolean secondSkystoneDetection = false;
    private ElapsedTime runTime = new ElapsedTime();
    private double previousRuntime = 0.1; //make it not 0 so it does not throw an error
    private double currentRuntime = 0;
    private DcMotor xrail = null;
    private double startingPos;
    private Servo intakeServo;
    private Servo armLeft;
    private int opposite = -1;


    //vuforia stuff
    private static final CameraDirection CAMERA_CHOICE = FRONT;
    private static final boolean PHONE_IS_PORTRAIT = false;

    private static final String VUFORIA_KEY = "AbZUuPf/////AAAAGUmS0Chan00iu7rnRhzu63+JgDtPo889M6dNtjvv+WKxiMJ8w2DgSJdM2/zEI+a759I7DlPj++D2Ryr5sEHAg4k1bGKdo3BKtkSeh8hCy78w0SIwoOACschF/ImuyP/V259ytjiFtEF6TX4teE8zYpQZiVkCQy0CmHI9Ymoa7NEvFEqfb3S4P6SicguAtQ2NSLJUX+Fdn49SEJKvpSyhwyjbrinJbak7GWqBHcp7fGh7TNFcfPFMacXg28XxlvVpQaVNgkvuqolN7wkTiR9ZMg6Fnm0zN4Xjr5lRtDHeE51Y0bZoBUbyLWSA+ts3SyDjDPPUU7GMI+Ed/ifb0csVpM12aOiNr8d+HsfF2Frnzrj2";

    // Since ImageTarget trackables use mm to specifiy their dimensions, we must use mm for all the physical dimension.
    // We will define some constants and conversions here
    private static final float mmPerInch        = 25.4f;
    private static final float mmTargetHeight   = (6) * mmPerInch;          // the height of the center of the target image above the floor

    // Constant for Stone Target
    private static final float stoneZ = 2.00f * mmPerInch;
    private boolean hasHitCase12 = false;

    // Constants for the center support targets
    private static final float bridgeZ = 6.42f * mmPerInch;
    private static final float bridgeY = 23 * mmPerInch;
    private static final float bridgeX = 5.18f * mmPerInch;
    private static final float bridgeRotY = 59;                                 // Units are degrees
    private static final float bridgeRotZ = 180;

    // Constants for perimeter targets
    private static final float halfField = 72 * mmPerInch;
    private static final float quadField  = 36 * mmPerInch;

    // Class Members
    private OpenGLMatrix lastLocation = null;
    private VuforiaLocalizer vuforia = null;
    private boolean targetVisible = false;
    private float phoneXRotate    = 0;
    private float phoneYRotate    = 0;
    private float phoneZRotate    = 0;

    private VuforiaTrackables targetsSkyStone;
    private List<VuforiaTrackable> allTrackables;
    private double skystoneOffset;
    private double XrailWheelSpeed = .6;
    private boolean skystoneDetected = false;

    /**
     * file reading variables
     */

    private boolean out = false;
    private boolean locked = false;
    private boolean dLeft = false;
    private boolean dRight = false;
    private int flPos = 0;
    private int frPos = 0;
    private int blPos = 0;
    private int brPos = 0;
    private int swPos = 0;
    private boolean dUp = false;
    private boolean dDown = false;
    private boolean aPressed = false;
    private boolean bPressed = false;
    private boolean xPressed = false;
    private boolean yPressed = false;
    private ArrayList<String> commands = null;
    private int commandIndex = 0;
    private boolean onFirstIteration = true;

    // Retrieve and initialize the IMU. We expect the IMU to be attached to an I2C port
    // on a Core Device Interface Module, configured to be a sensor of type "AdaFruit IMU",
    // and named "imu".

    private void DriveTrain(int distance) { //if positive, forwards. if negative, backwards

        int position = calculateTicks(distance);

        double power = 0.7; //starts at 0.7, then reduces as it gets closer
        //double power = powerScaleDistance(distance);

        position = -position; //right now, positive number goes backwards, so do opposite

        /**
         if (position < 0) {
         position = -position; //go backwards
         }
         */
        /*
        else if (position > 0) {
            position = position; //go forwards
        }
        else {
            position = 0;
        }
        */
        //power-scale factor, which is based on the distance needed to travel

        fl.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); //RunMode is an enum, a construct that defines
        //possible values, like STOP_AND_RESET_ENCODER
        //fl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        fl.setTargetPosition(position);
        fl.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        fr.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        //fr.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        fr.setTargetPosition(position);
        fr.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        bl.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        //bl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        bl.setTargetPosition(position);
        bl.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        br.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        //br.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        br.setTargetPosition(position);
        br.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        fl.setPower(power);
        fr.setPower(power);
        bl.setPower(power);
        br.setPower(power);

        //runTime.reset(); //reset bc PID control method needs the runtime since initialization
    }
    private void DriveTrain2(int position1, int position2, int position3, int position4) { //if positive, forwards. if negative, backwards

        double power = 1; //starts at 0.7, then reduces as it gets closer
        //double power = powerScaleDistance(distance);

        position1 = -position1; //right now, positive number goes backwards, so do opposite
        position2 = -position2; //right now, positive number goes backwards, so do opposite
        position3 = -position3; //right now, positive number goes backwards, so do opposite
        position4 = -position4; //right now, positive number goes backwards, so do opposite


        //frontLeftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); //RunMode is an enum, a construct that defines
        //possible values, like STOP_AND_RESET_ENCODER
        //fl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        fl.setTargetPosition(position1);
        fl.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        //frontRightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        //fr.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        fr.setTargetPosition(position2);
        fr.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        //backLeftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        //backLeftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        bl.setTargetPosition(position3);
        bl.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        //backRightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        //backRightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        br.setTargetPosition(position4);
        br.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        fl.setPower(power);
        fr.setPower(power);
        bl.setPower(power);
        br.setPower(power);
    }
    private void PIDcontrol() {
        //here the distance represents the offset from the target Position
        //the error for each motor (Current position) seemed to be different for some reason

        //one thing we could do is take the average of the four positions to make it more equal,
        //since for some reason only fr was a different amount

        /**
         double elapsedTime = Double.parseDouble(runTime.toString()) - previousRuntime; //currentRunTime
         */

        //double elapsedTime = 1.0;
        //minus the previous, which is the elapsed time since last call
        //previousRuntime starts at 0.1 in the first call

        prev_error = error;
        //get the error, or the distance from the target
        double averageCurrentPosition = (fl.getCurrentPosition() + fr.getCurrentPosition() + bl.getCurrentPosition()
                + br.getCurrentPosition()) / 4;

        error = Math.abs(Math.abs(averageCurrentPosition) - (Math.abs(targetPosition)));

        //to make the error fit within the range of 0-1, we can divide it by the original targetPosition
        //i.e if the error is like 1600 in the beginning, then obviously the target position is 1600
        //but as error gets smaller, gets closer


        //scale error

        error /= targetPosition; //scales it, halfway becomes error of 0.5
        //scales from 1 to 0

        error = 1 - error; //if its 1, becomes 0, if its 0, becomes 1. this is so that I can properly
        //scale the error along a sinusodial function (as x increases)

        //
        // new function scales error at the start from 0.4 to low of 0.1
        /// since error correlates with power, this will ensure a low power at the beginning,
        // increased power towards the middle, and low power towards the end (but not 0)
        //
        error = 0.9 * Math.sin ((Math.PI / 1.1) * error + 0.24) + 0.1;

        //one error we end up having is that scaling it like above, from 1 to 0, doesn't work very well
        //as it approaches 0, it takes too long, so we need a sinusoidal function
        //bot also immediately has set power of 0.7 at start, we should start slow and gear up for
        //more precise movement, as shown by the sine function

        diff_error = (error - prev_error); //difference in the errors for the kd constant,
        //and divided by elapsedTime to find the change in error

        sum_error += error; //add the error to the total number of errors

        //since error is too large in this case
        double driveSpeed = kp * error + ki * sum_error + kd * diff_error;

        fl.setPower(driveSpeed);
        fr.setPower(driveSpeed);
        bl.setPower(driveSpeed);
        br.setPower(driveSpeed);

        //now set the previous runtime
        /**
         prev_error = error;
         //get the error, or the distance from the target
         //double averageCurrentPosition = (frontLeftDrive.getCurrentPosition() + frontRightDrive.getCurrentPosition() + backLeftDrive.getCurrentPosition()
         //        + backRightDrive.getCurrentPosition()) / 4;
         //do one motor only
         error = (fl.getCurrentPosition() + fr.getCurrentPosition() + bl.getCurrentPosition()
         + br.getCurrentPosition()) / 4;
         //to make the error fit within the range of 0-1, we can divide it by the original targetPosition
         //i.e if the error is like 1600 in the beginning, then obviously the target position is 1600
         //but as error gets smaller, gets closer
         error /= targetPosition; //scales it, halfway becomes error of 0.5
         //scales from 1 to 0
         error = 1 - error; //if its 1, becomes 0, if its 0, becomes 1. this is so that I can properly
         //scale the error along a sinusodial function (as x increases)
         /**
         * new function scales error at the start from 0.4 to low of 0.1
         * since error correlates with power, this will ensure a low power at the beginning,
         * increased power towards the middle, and low power towards the end (but not 0)
         */
        //double driveSpeed = 0.9 * Math.sin ((Math.PI / 1.1) * error + 0.24) + 0.1;
        //double driveSpeed = 0.6 * Math.sin((Math.PI / 2.0) * error + 1.2) + 0.6;

        //one error we end up having is that scaling it like above, from 1 to 0, doesn't work very well
        //as it approaches 0, it takes too long, so we need a sinusoidal function
        //bot also immediately has set power of 0.7 at start, we should start slow and gear up for
        //more precise movement, as shown by the sine function

        //diff_error = (error - prev_error) / elapsedTime; //difference in the errors for the kd constant,
        //and divided by elapsedTime to find the change in error

        //sum_error += error; //add the error to the total number of errors

        //since error is too large in this case
        //double driveSpeed = kp * error + ki * sum_error + kd * diff_error;


        /**
         previousRuntime = Double.parseDouble(runTime.toString()); //set the previousRunTime, which is the current
         */
    }
    private int calculateTicks(int distance) {
        double circumTraveled = distance / wheelCircum;
        int position = (int) (ticksPerTurn * circumTraveled); //encoder value
        return position;
    }
    private void gyroCorrect(double gyroTarget) { //turn function utilizing the imu
        //make gyroTarget the opposite since it was going the opposite direction
        //gyroTarget *= -1; //make it the oppostie angle
        //lets say we are at 90 degree angle

        //also remember the calibration file
        //some things to change, the commented out part at the top
        //maybe the run to encoder
        //turn function
        //how it's called
        double gyroActual = getCurrentHeading();
        /**
         * these are constants, should be defined here
         */

        final double gyroRange = 0.5;
        final double minSpeed = 0.2;
        final double addSpeed = 0.1;
        //double gyroActual = getGyroRotation(unit) - lastAngle; //gets the current gyro rotation, but if we want to
        //make the new heading 0 after it turns for simple code, we need to make changes
        //basically we say that the new GyroTarget is

        //let's say the last angle achieved was 90 degrees...
        //by subtracting it we make the new heading 0

        //gyroTarget can stay the same since it is relative to the new heading

        //while ((gyroTarget - getGyroRotation(unit) + 360.0) % 360.0 < 0.5) {

        //this makes it an actual angle between 0 and 360 anyways, so it doesn't matter if the target
        //is weird for the gyro or actually between 0 and 360

        //assume that the gyroTarget is 90, and current position is 0. If threhold is 5 degrees, then
        double delta = (gyroTarget - gyroActual + 360.0) % 360.0; // in case it is negative
        //then delta is 90. Since the absolute value is greater than the gyroRange,
        //

        if (delta > 180.0) {
            delta -= 360.0; // delta becomes between -180 and 180
            //because the range is from 0-> 180 and -180-> 0 instead of 0-> 360
        }

        if (Math.abs(delta) > gyroRange) {
            double gyroMod = delta / 45.0; // if delta is less than 45 and bigger than -45, this will make a scale from
            // -1 to 1

            if (Math.abs(gyroMod) > 1.0) {
                gyroMod = Math.signum(gyroMod); //makes gyroMod -1 or 1 if error is more than 45
                // or less than -45 degrees
            }

            //if the error is more than 180, then the power is positive, and it turns to the left
            //if the error is less than 180, the power in the turn in negative, and it turns to the
            //right
            //if the error is larger, faster speed
            this.turn(minSpeed * Math.signum(gyroMod) + addSpeed * gyroMod);
        } else {
            turn(0.0);
        }
        //}
    }
    private void setLastAngle() {
        lastAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle;
    }

    private double getCurrentHeading() { //the relative one, which is after the heading becomes 0
        return gyroActual = getGyroRotation(unit) - lastAngle;
    }

    private void turn(double power) {
        //must set the runMode to run without encoder in order for it to run
        fl.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        fr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        bl.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        br.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        //changed the direction, changed it back bc of the issue
        fl.setPower(power);
        fr.setPower(-power);
        bl.setPower(power);
        br.setPower(-power);
    }

    //gets current angle position, which is relative to initial initialization (not relative to last position)

    private float getGyroRotation(AngleUnit unit) {
        //first angle means the x coordinate, or the heading
        return imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, unit).firstAngle;
    }
    private void correctAngle() {
        double angleOffset = getCurrentHeading() - 0;
        if (Math.abs(angleOffset) > 2.5) { //ideally, it should be at zero since
            //the method set last angle makes the new angle 0
            //but if the difference is greater than 2.5, we must correct
            gyroCorrect(-angleOffset); //we want to go in the correct direction
        }
        else {
            setLastAngle(); //if we no longer have to turn, we may have already completed it.
            //in that case, we set the last angle to current angle for future calculations
        }
    }
    private boolean targetVisible() {//this now returns the offset of the skystone
        targetVisible = false;
        //double yTranslation = 696969.69;
        VuforiaTrackable trackable = allTrackables.get(0);
        if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {
            targetVisible = true;
        }
        return targetVisible;
    }
    private void simpleDrive(double power) {
        fl.setPower(power);
        fr.setPower(power);
        bl.setPower(power);
        br.setPower(power);
    }

    @Override
    public void init() {
        fl = hardwareMap.dcMotor.get("fl");
        fr = hardwareMap.dcMotor.get("fr");
        bl = hardwareMap.dcMotor.get("bl");
        br = hardwareMap.dcMotor.get("br");

        //colorSensor = hardwareMap.get(ColorSensor.class, "colorSensor");

        fl.setDirection(DcMotor.Direction.FORWARD); //because the wheels are pointed in opposite directions
        fr.setDirection(DcMotor.Direction.REVERSE);
        bl.setDirection(DcMotor.Direction.FORWARD);
        br.setDirection(DcMotor.Direction.REVERSE);

        xrail = hardwareMap.get(DcMotor.class, "xRailMotor");
        xrail.setDirection(DcMotor.Direction.FORWARD);

        intakeServo = hardwareMap.get(Servo.class, "intakeServo");

        armLeft = hardwareMap.get(Servo.class, "armLeft");

        parameters = new BNO055IMU.Parameters();
        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;
        //parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
        parameters.calibrationDataFile = "BNO055IMUCalibration.json"; // see the calibration sample opmode
        parameters.loggingEnabled      = true;
        parameters.loggingTag          = "IMU";

        imu = hardwareMap.get(BNO055IMU.class, "imu");

        //initialize with these parameters
        imu.initialize(parameters);
        //parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();
        /**
         * VUFORIA
         */
        //camera initialization vuforia, we made a new parameter object because the gyro was the other one
        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
        VuforiaLocalizer.Parameters parameters2 = new VuforiaLocalizer.Parameters(cameraMonitorViewId);

        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();

        parameters2.vuforiaLicenseKey = VUFORIA_KEY;
        parameters2.cameraDirection   = CAMERA_CHOICE;

        //  Instantiate the Vuforia engine
        vuforia = ClassFactory.getInstance().createVuforia(parameters2);

        // Load the data sets for the trackable objects. These particular data
        // sets are stored in the 'assets' part of our application.
        targetsSkyStone = this.vuforia.loadTrackablesFromAsset("Skystone");

        VuforiaTrackable stoneTarget = targetsSkyStone.get(0);
        stoneTarget.setName("Stone Target");

        // For convenience, gather together all the trackable objects in one easily-iterable collection */
        //but for us there is only one
        allTrackables = new ArrayList<VuforiaTrackable>();
        allTrackables.addAll(targetsSkyStone);

        //set the stone target location
        stoneTarget.setLocation(OpenGLMatrix
                .translation(0, 0, stoneZ)
                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));

        /**
         * initialize the phone and coordinates
         */

        if (CAMERA_CHOICE == BACK) {
            phoneYRotate = -90;
        } else {
            phoneYRotate = 90;
        }

        // Rotate the phone vertical about the X axis if it's in portrait mode
        if (PHONE_IS_PORTRAIT) {
            phoneXRotate = 90;
        }

        // Next, translate the camera lens to where it is on the robot.
        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.
        final float CAMERA_FORWARD_DISPLACEMENT  = 3.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot center
        final float CAMERA_VERTICAL_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 8 Inches above ground
        final float CAMERA_LEFT_DISPLACEMENT     = 6.0f * mmPerInch;     // eg: Camera is ON the robot's center line

        OpenGLMatrix robotFromCamera = OpenGLMatrix
                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)
                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));


        ((VuforiaTrackableDefaultListener) allTrackables.get(0).getListener()).setPhoneInformation(robotFromCamera, parameters2.cameraDirection);

        /**
         * init for the file reading
         */
        commandIndex = 0;
        String filename = "SkystoneDetection2.txt";

        File file = new File(Environment.getExternalStorageDirectory()+"/"+filename);

        commands = new ArrayList<String>(Arrays.asList(ReadWriteFile.readFile(file).split("\\[")[1].split("\\]")[0].split(",")));
    }
    @Override
    public void start() {
        telemetry.addLine("Status: Intialized. Ready to go.");
        telemetry.update();
        runTime.reset();

        targetsSkyStone.activate();
    }
    @Override
    public void loop() {
        //afterwards switch to state machines
        //get to
        switch(step) {
            case -2:
                DriveTrain(-3 * opposite); //go towards the blocks
                targetPosition = calculateTicks(-3 * opposite);
                step = 0;
                nextStep = 7;
                break;
            case -1:
                if (Math.abs(gyroTarget - getCurrentHeading()) < 1.5) { //reached target
                    setLastAngle(); //sets the last angle so the next turn will deduct the current angle and make the heading 0
                    turn(0); //set power to 0
                    step = nextStep;
                }
                else {
                    gyroCorrect(gyroTarget); //we re-run gyroCorrect in order to get adaptable speed
                }
                break;
            case 0:
                flReached = Math.abs(fl.getCurrentPosition()) >= Math.abs(targetPosition) - 20; //if it's negative it will never stop... but targetPosition would be positive
                frReached = Math.abs(fr.getCurrentPosition()) >= Math.abs(targetPosition) - 20;
                blReached = Math.abs(bl.getCurrentPosition()) >= Math.abs(targetPosition) - 20;
                brReached = Math.abs(br.getCurrentPosition()) >= Math.abs(targetPosition) - 20;

                if (flReached && frReached && blReached && brReached) {
                    //update to see if they are still under the target position
                    step = nextStep;
                    sum_error = 0; //now reset the KI constant
                }
                else {
                    PIDcontrol(); //uses PID control to adjust the power based on the position relative to the target
                    /**
                     correctAngle();
                     */
                    //if the angle is off, it gets corrected
                }
                break;
            case 1:
                DriveTrain(24); //go towards the blocks
                targetPosition = calculateTicks(24);
                step = 0;
                nextStep = 2;
                break;
            case 2:
                gyroCorrect(-86 * opposite); //changed to opposite bc
                gyroTarget = -86 * opposite;
                step = -1;
                nextStep = 3;
                break;
            case 3: //no stop and reset here, so there is not a problem
                //if the skystone is not recognized yet, then it continues to set power to w/o encoders
                try { //wait for the skystone recognition
                    Thread.sleep(1500);
                }
                catch (InterruptedException e){
                    telemetry.addLine("Error");
                }
                skystoneDetected = targetVisible(); //returns the offset. if skystone was not recognized,
                //offset is 0
                if (skystoneDetected) { //if it was recognized, there will be offset not equal to 696969.69
                    //simpleDrive(0); //stop the motors
                    step = -2; //go to next Step
                } else {
                    DriveTrain(-4 * opposite); //if not recognized, drive back a little
                    targetPosition = calculateTicks(-4 * opposite);
                    step = 0;
                    nextStep = 7; //come back to this case, to recognize block
                    toBridgeDist += -4; //7 inches offset
                    //step = 4; //keep executing this case until there is a detection
                }
                break;
            case 7:
                gyroCorrect(86 * opposite); //now turn towards the block
                gyroTarget = 86 * opposite;
                step = -1;
                nextStep = 8;
                break;
            /**
             * move x rail
             */
            case 8:
                DriveTrain(-4); //move backwards so x rail does not interfere with the skystone
                targetPosition = calculateTicks(-4);
                step = 0;
                nextStep = 9;
                break;
            case 9:
                armLeft.setPosition(.95); //turn the servo
                try {
                    Thread.sleep(2000);
                }
                catch (Exception e) {
                    telemetry.addLine("Morgan likes men.");
                }
                xrail.setPower(XrailWheelSpeed); //move the xrail
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) {
                    telemetry.addLine("Error.");
                }
                xrail.setPower(0);
                step = 10;
                break;
            case 10:
                intakeServo.setPosition(0);
                try {
                    Thread.sleep(1500);
                }
                catch (Exception e) {
                    telemetry.addLine("Error.");
                }
                DriveTrain(10); //now go towards the block to pick it up
                targetPosition = calculateTicks(10);
                step = 0;
                nextStep = 11;
                break;
            /**
             * now grab, turn back x rail
             */
            case 11:
                intakeServo.setPosition(1);
                try {
                    Thread.sleep(1500);
                }
                catch (Exception e) {
                    telemetry.addLine("Error.");
                }
                xrail.setPower(-XrailWheelSpeed); //move the xrail
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) {
                    telemetry.addLine("Error.");
                }
                xrail.setPower(0);
                step = 12;
                break;
            case 12:
                DriveTrain(-7); //now go backwards after picking up the block
                targetPosition = calculateTicks(-7);
                step = 0;
                nextStep = 13;
                break;
            case 13:
                gyroCorrect(-86 * opposite); //turns towards the bridge now
                gyroTarget = -86 * opposite;
                step = -1;
                nextStep = 14;
                break;
            case 14: //drives towards the bridge
                //amount that we have to move back
                /**
                 * encoderMovedPosition = encoderEndingPosition - encoderStartingPosition; //how much we have moved since initial
                 */
                distanceToDrive = toBridgeDist;
                //block detection
                //the amount moved should be added to amount towards the bridge, so like 45
                //now convert position to inches...smh

                //distanceToDrive
                //        = (encoderMovedPosition / ticksPerTurn * wheelCircum);

                DriveTrain((int)(distanceToDrive)); //drive towards the first block, with the encoder
                //difference and also distance to go under skybridge from first stone, which 45 inches
                targetPosition = calculateTicks((int)(distanceToDrive));
                step = 0;
                nextStep = 15;
                break;
            /**
             * now insert case for doing the file reading
             */
            case 15:
                if (onFirstIteration) {
                    fl.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
                    fr.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
                    bl.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
                    br.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
                    onFirstIteration = false;
                }
                if (commandIndex<commands.toArray().length) {

                    telemetry.addLine("working.");

                    String s1 = "";
                    String s2 = "";
                    String s3 = "";
                    String s4 = "";
                    String s5 = "";
                    String s6 = "";
                    String s7 = "";
                    String s8 = "";
                    String s9 = "";
                    String s10 = "";
                    String s11 = "";
                    String s12 = "";
                    String s13 = "";

                    int count = 0;
                    for (String e: commands.get(commandIndex).replaceAll("  ", " ").split(" ", 0)) { //each string in the line
                        if (count < commands.get(commandIndex).replaceAll("  ", " ").split(" ", 0).length) {
                            if (e.equals("")) { //one of these strings is ""
                                oneIsNull = true;
                            }
                            else {
                                //telemetry.log().add(e);
                                if (s1.equals("")) {
                                    s1 = e;
                                }
                                else if (s2.equals("")) {
                                    s2 = e;
                                }
                                else if (s3.equals("")) {
                                    s3 = e;
                                }
                                else if (s4.equals("")) {
                                    s4 = e;
                                }
                                else if (s5.equals("")) {
                                    s5 = e;
                                }
                                else if (s6.equals("")) {
                                    s6 = e;
                                }
                                else if (s7.equals("")) {
                                    s7 = e;
                                }
                                else if (s8.equals("")) {
                                    s8 = e;
                                }
                                else if (s9.equals("")) {
                                    s9 = e;
                                }
                                else if (s10.equals("")) {
                                    s10 = e;
                                }
                                else if (s11.equals("")) {
                                    s11 = e;
                                }
                                else if (s12.equals("")) {
                                    s12 = e;
                                }
                                else if (s13.equals("")) {
                                    s13 = e;
                                }
                            }
                            count++;
                        }
                    }

                    if (!s1.equals("") && !s2.equals("") && !s3.equals("") && !s4.equals("") && !s5.equals("") && !s6.equals("")
                            && !s7.equals("") && !s8.equals("") && !s9.equals("") && !s10.equals("") && !s11.equals("")) { //if none are empty
                        flPos = -parseInt(s1);
                        frPos = -parseInt(s2);
                        blPos = -parseInt(s3);
                        brPos = -parseInt(s4); //it's usually the opposite
                        swPos = parseInt(s5);
                        dUp = parseBoolean(s6);
                        dDown = parseBoolean(s7);
                        aPressed = parseBoolean(s8);
                        bPressed = parseBoolean(s9);
                        xPressed = parseBoolean(s10);
                        yPressed = parseBoolean(s11);
                        dLeft = parseBoolean(s12);
                        dRight = parseBoolean(s13);
                        //servoGrab = parseBoolean(s5);
                    }

                    if (dUp){
                        xrail.setPower(-XrailWheelSpeed);
                    } else if (dDown){
                        xrail.setPower(XrailWheelSpeed);
                    } else {
                        xrail.setPower(0);
                    }

                    if (aPressed){
                        armLeft.setPosition(.95);
                        out = true;
                    } else if (bPressed){
                        armLeft.setPosition(.1);
                        out = false;
                    }

                    if (out){
                        armLeft.setPosition(.95);
                    }

                    if (dLeft && locked){
                        locked = false;
                    } else if (dRight && !locked){
                        locked = true;
                    }

                    if (xPressed){
                        intakeServo.setPosition(1);
                    } else if (yPressed){
                        intakeServo.setPosition(0);
                    } else if (!locked){
                        intakeServo.setPosition(.5);
                    }

                    DriveTrain2(flPos, frPos, blPos, brPos); //reset encoder values?

                    flReached = Math.abs(fl.getCurrentPosition()) >= Math.abs(flPos) - 175;
                    //threshold value to account for the lag, proportionate to power set
                    frReached = Math.abs(fr.getCurrentPosition()) >= Math.abs(frPos) - 175;
                    blReached = Math.abs(bl.getCurrentPosition()) >= Math.abs(blPos) - 175;
                    brReached = Math.abs(br.getCurrentPosition()) >= Math.abs(brPos) - 175;
                    //swReached = Math.abs(stringWheel.getCurrentPosition()) >= Math.abs(swPos) - 100;

                    if (flReached && frReached && blReached && brReached) { //once reached, go to next set
                        commandIndex++;
                    }

                    //commandIndex++;

                    // telemetry.log().add(oneIsNull + "");
                    // telemetry.log().add(count + "");
                    //telemetry.log().add(flPos + "");
                    //telemetry.log().add(frPos + "");
                    //telemetry.log().add(blPos + "");
                    //telemetry.log().add(brPos + "");
                    //telemetry.log().add(servoGrab + "");
                    //telemetry.log().add(" ");
                    //telemetry.log().add(" ");
                    //telemetry.log().add(" ");
                    //telemetry.log().add(" ");
                    //commandIndex++;

                    iter++;
                    /**
                     try {
                     //we replace the double spaces with the single spaces
                     //replaceAll("  ", " ").replaceAll("", " ")
                     flPos = parseInt(commands.get(commandIndex).split(" ")[0]); //get the first element in the iteration as int
                     frPos = parseInt(commands.get(commandIndex).replaceAll("  ", " ").replaceAll("", " ").split(" ")[1]); //get the second element in the iteration
                     blPos = parseInt(commands.get(commandIndex).replaceAll("  ", " ").replaceAll("", " ").split(" ")[2]); //get the third element in the iteration
                     brPos = parseInt(commands.get(commandIndex).replaceAll("  ", " ").replaceAll("", " ").split(" ")[3]); //get the fourth element in the iteration

                     telemetry.addData("Flpos:", flPos);
                     telemetry.addData("Frpos:", frPos);
                     telemetry.addData("Blpos:", blPos);
                     telemetry.addData("Brpos:", brPos);

                     commandIndex++;
                     }
                     catch (NumberFormatException e) {
                     telemetry.addData("flPos:", commands.get(commandIndex).split(" ")[0]);
                     }
                     */
                    telemetry.addData("Iters:", iter);
                } else {
                    step = 16; //go to next step once done
                }
                break;
            case 16:
                break;
        }

        /**
         telemetry.addLine("fl: " + fl.getCurrentPosition());
         telemetry.addLine("fr: " + fr.getCurrentPosition());
         telemetry.addLine("bl: " + bl.getCurrentPosition());
         telemetry.addLine("br: " + br.getCurrentPosition());
         telemetry.addLine("red" + colorSensor.red());
         telemetry.addLine("blue" + colorSensor.blue());
         telemetry.addLine("green" + colorSensor.green());
         telemetry.update();
         */

        telemetry.addData("Current Heading/Angle:", getCurrentHeading());
        telemetry.addData("fl: ", fl.getCurrentPosition());
        telemetry.addData("fr: ", fr.getCurrentPosition());
        telemetry.addData("br: ", fr.getCurrentPosition());
        telemetry.addData("bl: ", fr.getCurrentPosition());
        telemetry.addData("target position: ", targetPosition);
        telemetry.addData("case: ", step);
        if (step == 12) {
            hasHitCase12 = true;
        }
        telemetry.addData("has gone to case 12", hasHitCase12);
        telemetry.addData("skystone error: ", skystoneOffset);
        telemetry.addData("Skystone distance:", distanceToDrive);
        //telemetry.addData("Difference", Math.abs(gyroTarget - getCurrentHeading()));
        telemetry.update();

    }
    @Override
    public void stop() {
    }
}
